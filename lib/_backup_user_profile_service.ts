import { jwtVerify } from 'jose'\n\nexport interface UserProfile {\n  id: string\n  email: string\n  name?: string\n  preferred_username?: string\n  role: 'admin' | 'analyst' | 'security_lead'\n  permissions: string[]\n  assignedInvestigations: Investigation[]\n  continuedInvestigations: Investigation[]\n  completedInvestigations: Investigation[]\n  createdAt: string\n  lastActive: string\n}\n\nexport interface Investigation {\n  id: string\n  uniqueId: string\n  emailId: string\n  emailSubject: string\n  sender: string\n  severity: 'Critical' | 'High' | 'Medium' | 'Low'\n  status: 'new' | 'in_progress' | 'completed' | 'escalated' | 'blocked'\n  assignedTo: string[]\n  assignedBy?: string\n  startedAt: string\n  lastUpdated: string\n  completedAt?: string\n  notes: string[]\n  escalatedToAdmin: boolean\n  escalatedBy?: string\n  escalationReason?: string\n  conflictWarnings: ConflictWarning[]\n}\n\nexport interface ConflictWarning {\n  type: 'multiple_investigators' | 'already_assigned'\n  message: string\n  users: string[]\n  timestamp: string\n}\n\nexport interface Assignment {\n  id: string\n  uniqueId: string\n  title: string\n  description: string\n  severity: 'Critical' | 'High' | 'Medium' | 'Low'\n  status: 'new' | 'in_progress' | 'completed' | 'escalated'\n  assignedTo: string[]\n  assignedBy: string\n  createdAt: string\n  dueDate?: string\n  priority: number\n  tags: string[]\n  relatedEmails: string[]\n}\n\nexport interface BlockedEmail {\n  id: string\n  email: string\n  reason: 'manual_block' | 'ai_detection' | 'security_team_block' | 'admin_block'\n  blockedBy: string\n  blockedAt: string\n  severity: 'Critical' | 'High' | 'Medium' | 'Low'\n  orgInteractions: number\n  lastInteraction?: string\n  notes?: string\n}\n\nexport interface PushedRequest {\n  id: string\n  originalInvestigationId: string\n  emailSubject: string\n  sender: string\n  severity: 'Critical' | 'High' | 'Medium' | 'Low'\n  pushedBy: string\n  pushedAt: string\n  reason: string\n  status: 'pending' | 'in_review' | 'completed' | 'rejected'\n  reviewedBy?: string\n  reviewedAt?: string\n  adminNotes?: string\n}\n\nclass UserProfileService {\n  private profiles: Map<string, UserProfile> = new Map()\n  private investigations: Map<string, Investigation> = new Map()\n  private assignments: Map<string, Assignment> = new Map()\n  private blockedEmails: Map<string, BlockedEmail> = new Map()\n  private pushedRequests: Map<string, PushedRequest> = new Map()\n\n  // Initialize default roles and permissions\n  private readonly DEFAULT_PERMISSIONS = {\n    admin: [\n      'view_all_investigations',\n      'assign_investigations',\n      'escalate_investigations',\n      'manage_users',\n      'manage_roles',\n      'view_pushed_requests',\n      'review_pushed_requests',\n      'block_emails',\n      'manage_blocked_emails',\n      'view_all_assignments',\n      'create_assignments',\n      'manage_employees'\n    ],\n    security_lead: [\n      'view_team_investigations',\n      'assign_investigations',\n      'escalate_investigations',\n      'view_assignments',\n      'create_assignments',\n      'push_to_admin',\n      'block_emails',\n      'view_blocked_emails'\n    ],\n    analyst: [\n      'view_own_investigations',\n      'update_investigations',\n      'push_to_admin',\n      'view_own_assignments',\n      'view_blocked_emails'\n    ]\n  }\n\n  // Get or create user profile from JWT token\n  async getUserProfile(token: string): Promise<UserProfile> {\n    try {\n      const secret = new TextEncoder().encode(process.env.JWT_SECRET || 'your-secret-key')\n      const { payload } = await jwtVerify(token, secret)\n      \n      const userId = payload.sub || payload.email as string\n      const email = payload.email as string\n      const name = payload.name as string || payload.preferred_username as string\n      const preferred_username = payload.preferred_username as string\n\n      // Check if profile exists, create if not\n      if (!this.profiles.has(userId)) {\n        const newProfile: UserProfile = {\n          id: userId,\n          email,\n          name,\n          preferred_username,\n          role: 'analyst', // Default role\n          permissions: this.DEFAULT_PERMISSIONS.analyst,\n          assignedInvestigations: [],\n          continuedInvestigations: [],\n          completedInvestigations: [],\n          createdAt: new Date().toISOString(),\n          lastActive: new Date().toISOString()\n        }\n        this.profiles.set(userId, newProfile)\n      }\n\n      // Update last active\n      const profile = this.profiles.get(userId)!\n      profile.lastActive = new Date().toISOString()\n      \n      return profile\n    } catch (error) {\n      throw new Error('Invalid token')\n    }\n  }\n\n  // Update user role and permissions\n  updateUserRole(userId: string, role: UserProfile['role']): UserProfile | null {\n    const profile = this.profiles.get(userId)\n    if (!profile) return null\n\n    profile.role = role\n    profile.permissions = this.DEFAULT_PERMISSIONS[role]\n    return profile\n  }\n\n  // Check if user has permission\n  hasPermission(userId: string, permission: string): boolean {\n    const profile = this.profiles.get(userId)\n    if (!profile) return false\n    return profile.permissions.includes(permission)\n  }\n\n  // Investigation management\n  createInvestigation(data: Omit<Investigation, 'id' | 'startedAt' | 'lastUpdated' | 'conflictWarnings'>): Investigation {\n    const investigation: Investigation = {\n      ...data,\n      id: `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      startedAt: new Date().toISOString(),\n      lastUpdated: new Date().toISOString(),\n      conflictWarnings: []\n    }\n    \n    this.investigations.set(investigation.id, investigation)\n    \n    // Add to assigned users' profiles\n    investigation.assignedTo.forEach(userId => {\n      const profile = this.profiles.get(userId)\n      if (profile) {\n        profile.assignedInvestigations.push(investigation)\n      }\n    })\n    \n    return investigation\n  }\n\n  // Assign investigation with conflict detection\n  assignInvestigation(investigationId: string, assignToUserId: string, assignedBy: string): { success: boolean, warnings: ConflictWarning[] } {\n    const investigation = this.investigations.get(investigationId)\n    if (!investigation) return { success: false, warnings: [] }\n\n    const warnings: ConflictWarning[] = []\n\n    // Check if already assigned to someone else\n    if (investigation.assignedTo.length > 0 && !investigation.assignedTo.includes(assignToUserId)) {\n      const warning: ConflictWarning = {\n        type: 'multiple_investigators',\n        message: `This investigation is already being worked on by ${investigation.assignedTo.length} other user(s)`,\n        users: investigation.assignedTo,\n        timestamp: new Date().toISOString()\n      }\n      warnings.push(warning)\n      investigation.conflictWarnings.push(warning)\n    }\n\n    // Add user to investigation\n    if (!investigation.assignedTo.includes(assignToUserId)) {\n      investigation.assignedTo.push(assignToUserId)\n      investigation.status = 'in_progress'\n      investigation.lastUpdated = new Date().toISOString()\n\n      // Add to user's profile\n      const profile = this.profiles.get(assignToUserId)\n      if (profile) {\n        profile.assignedInvestigations.push(investigation)\n      }\n    }\n\n    return { success: true, warnings }\n  }\n\n  // Get user's investigations\n  getUserInvestigations(userId: string): {\n    assigned: Investigation[]\n    continued: Investigation[]\n    completed: Investigation[]\n  } {\n    const profile = this.profiles.get(userId)\n    if (!profile) return { assigned: [], continued: [], completed: [] }\n\n    const assigned = Array.from(this.investigations.values()).filter(\n      inv => inv.assignedTo.includes(userId) && inv.status !== 'completed'\n    )\n\n    const continued = assigned.filter(inv => inv.status === 'in_progress')\n    const completed = Array.from(this.investigations.values()).filter(\n      inv => inv.assignedTo.includes(userId) && inv.status === 'completed'\n    )\n\n    return { assigned, continued, completed }\n  }\n\n  // Assignment management\n  createAssignment(data: Omit<Assignment, 'id' | 'createdAt'>): Assignment {\n    const assignment: Assignment = {\n      ...data,\n      id: `asn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      createdAt: new Date().toISOString()\n    }\n    \n    this.assignments.set(assignment.id, assignment)\n    return assignment\n  }\n\n  getUserAssignments(userId: string): Assignment[] {\n    return Array.from(this.assignments.values()).filter(\n      assignment => assignment.assignedTo.includes(userId)\n    ).sort((a, b) => {\n      // Priority: in_progress first, then by priority number, then by creation date\n      if (a.status === 'in_progress' && b.status !== 'in_progress') return -1\n      if (b.status === 'in_progress' && a.status !== 'in_progress') return 1\n      if (a.priority !== b.priority) return a.priority - b.priority\n      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n    })\n  }\n\n  // Push request to admin\n  pushToAdmin(investigationId: string, pushedBy: string, reason: string): PushedRequest {\n    const investigation = this.investigations.get(investigationId)\n    if (!investigation) throw new Error('Investigation not found')\n\n    const pushedRequest: PushedRequest = {\n      id: `push_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      originalInvestigationId: investigationId,\n      emailSubject: investigation.emailSubject,\n      sender: investigation.sender,\n      severity: investigation.severity,\n      pushedBy,\n      pushedAt: new Date().toISOString(),\n      reason,\n      status: 'pending'\n    }\n\n    this.pushedRequests.set(pushedRequest.id, pushedRequest)\n    \n    // Update investigation status\n    investigation.status = 'escalated'\n    investigation.escalatedToAdmin = true\n    investigation.escalatedBy = pushedBy\n    investigation.escalationReason = reason\n    investigation.lastUpdated = new Date().toISOString()\n\n    return pushedRequest\n  }\n\n  // Blocked email management\n  blockEmail(email: string, reason: BlockedEmail['reason'], blockedBy: string, notes?: string): BlockedEmail {\n    const blockedEmail: BlockedEmail = {\n      id: `blk_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      email,\n      reason,\n      blockedBy,\n      blockedAt: new Date().toISOString(),\n      severity: 'Medium', // Default severity\n      orgInteractions: 0, // This would be populated from email analysis\n      notes\n    }\n\n    this.blockedEmails.set(email, blockedEmail)\n    return blockedEmail\n  }\n\n  // Get all data for different views\n  getAllPushedRequests(): PushedRequest[] {\n    return Array.from(this.pushedRequests.values()).sort(\n      (a, b) => new Date(b.pushedAt).getTime() - new Date(a.pushedAt).getTime()\n    )\n  }\n\n  getAllBlockedEmails(): BlockedEmail[] {\n    return Array.from(this.blockedEmails.values()).sort(\n      (a, b) => new Date(b.blockedAt).getTime() - new Date(a.blockedAt).getTime()\n    )\n  }\n\n  getAllUsers(): UserProfile[] {\n    return Array.from(this.profiles.values())\n  }\n\n  getAllInvestigations(): Investigation[] {\n    return Array.from(this.investigations.values())\n  }\n\n  getAllAssignments(): Assignment[] {\n    return Array.from(this.assignments.values()).sort(\n      (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n    )\n  }\n}\n  // Update a pushed request status (accept -> in_review, deny -> rejected, complete -> completed)\n  reviewPushedRequest(id: string, action: 'accept' | 'deny' | 'complete', reviewedBy: string, notes?: string): PushedRequest | null {\n    const req = this.pushedRequests.get(id)\n    if (!req) return null\n\n    if (action === 'accept') {\n      req.status = 'in_review'\n    } else if (action === 'deny') {\n      req.status = 'rejected'\n    } else if (action === 'complete') {\n      req.status = 'completed'\n    }\n    req.reviewedBy = reviewedBy\n    req.reviewedAt = new Date().toISOString()\n    if (notes) req.adminNotes = notes\n\n    this.pushedRequests.set(req.id, req)\n    return req\n  }\n\n  getRecentPushedRequests(limit = 5, status: PushedRequest['status'] | 'any' = 'pending'): PushedRequest[] {\n    const all = this.getAllPushedRequests()\n    const filtered = status === 'any' ? all : all.filter(r => r.status === status)\n    return filtered.slice(0, limit)\n    // Update a pushed request status (accept -> in_review, deny -> rejected, complete -> completed)
  reviewPushedRequest(id: string, action: 'accept' | 'deny' | 'complete', reviewedBy: string, notes?: string): PushedRequest | null {
    const req = this.pushedRequests.get(id)
    if (!req) return null

    if (action === 'accept') {
      req.status = 'in_review'
    } else if (action === 'deny') {
      req.status = 'rejected'
    } else if (action === 'complete') {
      req.status = 'completed'
    }
    req.reviewedBy = reviewedBy
    req.reviewedAt = new Date().toISOString()
    if (notes) req.adminNotes = notes

    this.pushedRequests.set(req.id, req)
    return req
  }

  getRecentPushedRequests(limit = 5, status: PushedRequest['status'] | 'any' = 'pending'): PushedRequest[] {
    const all = this.getAllPushedRequests()
    const filtered = status === 'any' ? all : all.filter(r => r.status === status)
    return filtered.slice(0, limit)
  }}\n\n\n// Export singleton instance\nexport const userProfileService = new UserProfileService()
